# Copilot Instructions

- Stack overview: Python crawler writes products into SQLite; Next.js app renders static catalog from JSON snapshots; FastAPI server wraps crawler control plus Airtable/Cloudinary order flows. Treat `data/out/*.json` as build-time content for the frontend.
- Primary entrypoints: [main.py](../main.py) runs crawl + optional export; [turbo.py](../turbo.py) is sitemap-only fast ingest; [update_all.py](../update_all.py) re-parses all sitemap URLs to refresh price/category fields; [server.py](../server.py) exposes crawler control/status + order endpoints (Airtable, Cloudinary) for the UI.
- Run crawler: `python main.py --config config/<supplier>.yaml --db products.db` (adds `db_path` for downstream). Use `--no-crawl --export` to export only, and `--export-frontend` to write frontend JSON to `data/out`.
- Sitemap fast path: `python turbo.py --config config/<supplier>.yaml --db products.db` pulls URLs from `base_url` + `/sitemap.xml`, skips SKUs already in DB, then parses via HTML selectors.
- Update pass: `python update_all.py --config config/<supplier>.yaml --db products.db` refreshes every sitemap URL with shorter delay; reuse for price/category updates without rediscovery.
- Exporting data: [crawler/pipeline.py](../crawler/pipeline.py) `DataPipeline.export_data(path, fmt=csv|xlsx|json)` reads SQLite; `FrontendExporter` in [crawler/exporter.py](../crawler/exporter.py) writes `products.frontend.json`, `categories.frontend.json`, `categories.flat.json` to `data/out/` (and these should be copied/symlinked into `frontend/public/data/` for the Next app and search page).
- DB schema & IDs: table `products` uses `catalog_id` (supplier_slug:sku_clean) as primary key; `product_id` is legacy SHA1. `normalize_url`, `clean_sku`, `slugify_supplier`, `generate_catalog_id` live in [crawler/utils.py](../crawler/utils.py). `content_hash` excludes timestamps to detect content changes; upserts use `ON CONFLICT(catalog_id)`.
- Crawler behavior: [crawler/core.py](../crawler/core.py) BFS-queues URLs seeded from `base_url`, allows only `allowed_domains`, and gates URLs by `category_url_patterns` / `product_url_patterns`. It loads existing SKUs from DB to skip duplicates. Static fetch via `requests` falls back to Playwright (`fetch_dynamic`) when `use_dynamic` or static fails.
- Parsing rules: [crawler/parser.py](../crawler/parser.py) uses Selectolax; selectors allow attributes via `selector::attr` and regex via `selector :: regex:pattern`. Special `breadcrumb` selector populates `category_path`. JSON-LD Product blocks are ingested first and overridden by CSS selectors.
- Config shape: see [config/template.yaml](../config/template.yaml) for `base_url`, `allowed_domains`, URL patterns, optional pagination meta, and CSS selectors. Set `supplier` and ensure patterns include `/product/` etc. Use `selectors.images` to collect list; properties table currently not parsed (non-dict coerced to `{}`).
- Integrity checks: run `python -m pytest tests/test_parser.py` (regex/attr parsing) or `python tests/verify_integrity.py` to ensure every row has `sku_clean`, `catalog_id`, and unique IDs.
- Server workflows: start UI/API with `uvicorn server:app --reload`. `.env` needs `AIRTABLE_PAT` for order records and `CLOUDINARY_URL` for uploads. `/api/start` and `/api/stop` manage the crawler process; `/api/status` inspects `products.db` counts; `/api/order/*` routes create/update Airtable rows and upload files to Cloudinary.
- Frontend data loading: [frontend/lib/data.ts](../frontend/lib/data.ts) reads snapshots from `../data/out`; client search page fetches `/data/products.frontend.json` (expects the same files mirrored under `frontend/public/data/`). Regenerate snapshots after crawling, else pages will be empty.
- Frontend routing: home lists top categories; category pages (`/c/[...slug]`) filter products by `category_slug_path`; product pages (`/p/[supplier_slug]/[sku_clean]/[slug]`) are statically generated from snapshot keys and show gallery, properties, and WhatsApp CTA.
- Search: [frontend/lib/search.ts](../frontend/lib/search.ts) builds a MiniSearch index on the client over snapshot data (fields: `title`, `sku`, `search_blob`, `supplier` with SKU boosted). Keep `search_blob` populated in exporter when changing schema.
- Mockup editor: [frontend/components/MockupEditor.tsx](../frontend/components/MockupEditor.tsx) is client-only, fabric.js-based with optional background removal; it saves mockups/orders through `useOrder` hook which posts to FastAPI `/api/order/*`. `app/api/mockups/route.ts` persists mockup JSON to `frontend/public/data/mockups/` (no DB).
- Layout/context: root layout wraps pages with `ToastProvider` and floating `OrderSummary` cart; RTL/Hebrew fonts via Heebo/Assistant in [frontend/app/layout.tsx](../frontend/app/layout.tsx). UI relies on Tailwind (see [frontend/app/globals.css](../frontend/app/globals.css)).
- Gotchas: `Product` model in [crawler/models.py](../crawler/models.py) requires `catalog_id`, `sku_clean`, `supplier_slug`, and valid `HttpUrl` for `url`/`images`; ensure inputs are normalized before `DataPipeline.process_item`. Playwright browsers may need `playwright install` after pip install. Keep DB migrations in sync if altering schema (old DBs may lack `catalog_id`/`sku_clean`).
